```table-of-contents
title: Содержание:
style: nestedList # TOC style (nestedList|inlineFirstLevel)
minLevel: 0 # Include headings from the specified level
maxLevel: 0 # Include headings up to the specified level
includeLinks: true # Make headings clickable
debugInConsole: false # Print debug info in Obsidian console
```
# Бенчмарк  в попугаях
Много лет назад на одном популярном англоязычном форуме, ныне покойном, предложили гениально простой способ нагреть проц и посчитать его скорость в попугаях.

```shell
time echo "scale=5000; 4*a(1)" | bc -l
```

bc - Си-подобный интерактивный интерпретатор. 
Подгружаем в bc математическую библиотеку опцией -l и просим выдать число π с точностью 5000 знаков после запятой.

---
# Просмотр известных портов
```shell
cat /etc/services | less
```

---
# Отрезаем расширение у файла

Стандартный способ — использовать утилиту `basename`, который отрезает весь путь слева, а если указать дополнительный параметр, то дополнительно отрежет справа и суффикс. Например пишем file.txt и суффикс .txt

```shell
basename file.txt .txt
```

>Получаем: file

Но можно обойтись внутренними преобразованиями в bash 
```shell
filename=file.txt; echo ${filename%.*}
```

>Получаем: file

Или наоборот, отрезать имя файла и оставить только расширение:
```shell
filename=file.txt; echo ${filename##*.}
```

>Получаем: txt

---
# Наблюдаем за командами 

Если вам необходимо следить за командами с изменяющимися выводимыми данными, используйте команду watch. 

>Например, чтобы следить за средней загрузкой, выполняем: 
```bash
watch "cat /proc/loadavg"
```
Каждые две секунды watch будет запускать команду cat. (Для завершения выполнения команды нажмите сочетание клавиш CTRL+C). 

>Чтобы увеличить частоту обновления до 10 секунд, выполняем: 
```bash
watch -n 10 "ls -l"
```

>Чтобы выделить разницу между обновлениями на экране, выполните:
```bash
watch -d "ls -l"
```

>Выводит список открытых файлов и сокетов, связанных с сетевыми соединениями.
```bash
watch lsof -i@192.168.0.2 -n -P
```

Для выполнения выделения необходимо, чтобы файлы изменялись.

---
# Как завершилась последняя команда — успешно или нет?

Можно получить статус завершения последней команды из переменной среды '$?', в ней хранится код завершения. Например:

```shell
ls -l /var/
echo $?
```
0

или

```shell
ls -l /var/wwer
echo $?
```
2

Код завершения 0 означает что команда выполнена успешно, любое отличное от нуля число свидетельствует об ошибке.

---
# Цветной вывод в консоли

Установка Debiam/Ubuntu
```bash
sudo apt install lolcat
```

Смотрим имеющиеся возможности:
```bash
lolcat -h
```

Можем использовать утилиту в комплекте с любой другой командой. К примеру:
```bash
ping google.com | lolcat
```

```bash
ps | lolcat
```

```bash
cal | lolcat
```

или выдать анимированный текст:
```bash
echo Hello World | lolcat -a -d 500
```

Пользы никакой, для развлечения, получается

---
# Команда find

Находим файлы размером более 10 МБ в каталоге /usr:
```shell
find /usr -size +10M
```

Находим в каталоге /home файлы, которые были изменены 120 дней назад:
```shell
find /home -mtime +120
```

Находим в каталоге /var файлы, к которым не обращались в течение 90 дней:
```shell
find /var \! -atime -90
```

Находим файл "core" во всем дереве каталогов. Если он найден, удаляем его без запроса:
```shell
find / -name core -exec rm {} \
```

---
# Команда uname

Ядро Linux и дистрибутивы, основанные на нем, разрабатываются отдельно от другого, поэтому у ядра есть своя схема управления версиями. Некоторые выпуски ядра достигают известной популярности, поэтому нет ничего необычного в том, что несколько независимых дистрибутивов используют одно и то же ядро. 

Чтобы узнать, в каком ядре работает данная система, выполните команду: 
```bash
uname -r
```

Остальные ключи:
`-s`   Имя ядра
`-n`   Имя узла системы (имя хоста). Это имя, которое система использует при общении по сети. Выдает тот же вывод, что и команда hostname
`-v`   Версия ядра
`-m`   Аппаратное имя
`-p`   Архитектура процессора
`-i`   Аппаратная платформа
`-o`   Распечатать название операционной системы. В системах Linux это «GNU / Linux»
`-a`   Ведет себя так же, как если бы были заданы: `-snrvmo`

---
# Монтирование файловой системы

Файловую систему необходимо смонтировать до того, как она станет видимой для процессов. 

Точкой монтирования для ФС может быть любой каталог. 

Например, команда 
```shell
sudo mount /dev/sda1 /mnt/temp
```

монтирует ФС в разделе, представленном файлом устройства /dev/sda1 в каталоге /mnt, который является традиционным для временных точек монтирования. 

Размер файловой системы можно проверить с помощью команды df.  Например:
```shell
df -h /mnt/web1
```

В приведенном примере флаг -h используется для выдачи результатов в понятном для человека виде.

---
# Команда date
Отобразит текущее системное значение в форматировании по умолчанию:
```bash
date
```

Пример форматированного вывода:
```bash
date +"Day: %d, Month: %m, Year: %Y"
```

Весь список по %.. смотрим в date --help

Строка даты принимает значения, такие как «завтра», «пятница», «последняя среда», «следующий вторник», «следующий месяц», «следующая неделя» .. и т. д.
```bash
date -d "next sunday"
```
или
```bash
date -d "15 days ago"
```

Самостоятельно устанавливать дату и время - крайне не рекомендуется, но сделать это можно так:
```bash
date --set="19691228 16:25"
```

Пример использования date в скриптах (взят с losst):
Если текущий день месяца — последний, сформировать отчет о занятости дискового пространства корневого и домашнего каталога в файл report.
```bash
#!/bin/bash
if [[ $(date --date='next day' +%d) = '01' ]]; then
df -h / /home > report
```

---
# Когда система подтормаживает, разобраться поможет:


```bash
ps aux --sort=-%cpu | grep -m 11 -v 'whoami'
```
Этой командой получим список из 10 (не ваших) процессов, которые больше всего нагружают процессор.

Либо можем получить весь список процессов, которые были запущены не вами:
```bash
ps aux | grep -v 'whoami'
```

Так смотрим список самых загруженных (в более читаемом виде):
```bash
ps -eo pid,ppid,%mem,%cpu,comm --sort=-%cpu | head
```

----
# Форк бомба

Один из способов издевательства над системой - Форк бомба

```bash
:(){
:|:&
};:
```

Это скрипт, который создает множество процессов, пока компьютер не зависнет.
Единственным решением остается отключение питания.

Что к чему:
`:()`  Определение функции.
`{`  Открытие функции.
`:|:`  Далее, загружает копию функции «:» в память тем самым, будет вызывать само себя рекурсивно. Передает результат на другой вызов функции.
‘:’   Худшая часть — функция, вызываемая два раза, чтобы «бомбить» вашу систему.
&  Помещает вызов функции в фоновом режиме, чтобы fork (дочерний процесс) не мог «умереть» вообще, тем самым это начнет есть системные ресурсы.
`}`  Закрытие функции.
`;`  Завершает определение функции. Разделяет команды.
`:`  Запускает функцию которая порождает fork bomb().

Некоторые дистрибутивы способны предотвращать такую атаку путем ограничения количества процессов от одного пользователя.

---
# Команда rm

(В приведенных примерах находимся в месте расположения файла)
Для удаления файла some_file используем rm с именем файла в качестве аргумента:
```shell
rm some_file
```

Можно сразу несколько:
```shell
rm some_file1 some_file2 some_file3
```

Удалить все файлы в текущей директории:
```shell
rm *
```

Выдавать запрос перед удалением каждого файла:
```shell
rm -i *
```

Удаляем директорию и ее содержимое:
```shell
rm -r mydir
```

Удаляем все файлы в каталоге, которые не соответствуют определенному расширению:
```shell
rm !(*.html | *.css | *.php | *.png)
```

---
# Арифметические операторы в сценариях оболочки

Если необходимо использовать арифметические операторы в сценариях оболочки, поможет команда expr (которая выполняет даже некоторые операции со строками). 

Например: expr 5 + 2 выводит результат 7. 

Полный перечень операций: expr --help

expr не хранит результат, а по умолчанию просто печатает ответ. Но никто не запрещает сохранять результат в переменные: 
```shell
A=$( expr 12 - 7 )
echo $A # 5
```

Применение команды expr — это неуклюжий и медленный способ выполнения математических вычислений. 

Если вам часто приходится заниматься ими, то, лучше использовать что-то вроде Python.

---
# Команда split
Разбить файл на части можно используя команду split

Для примера создадим файл с цифрами от 1 до 1000 в столбик командой:
```bash
echo {1..1000} | tr ' ' '\n' > some_file
```

Разделим этот файл по 200 строк в каждом, командой:
```bash
split -200 some_file
```

Цифру можно задать свою. Исходный some_file останется, рядом создадутся 5 (потому что на 200  делили) файлов. Подумай, какие названия им даст ОС?

Команду можно также использовать для разделения файлов на части по размеру информации, например: 
```bash
split -b100b some_file2
split -b100k some_file2
split -b100m some_file2
```

Первая команда разделит файл на части по 100 байтов каждая, вторая - на части по 100 Кбайт каждая, третья - по 100 Мбайт каждая.

---
# Атрибуты файла

В Linux кроме прав доступа есть еще и атрибуты файла, подобно атрибутам файла в других ОС. 

 Просмотреть установленные атрибуты можно командой:
```bash
chattr some_file
```

Основные полезные атрибуты:
`i` Запрет на изменений, переименование и удаление файла. Обычно ставится для критических конфиг. файлов. Установить и сбросить может только root (либо процесс с CAP_LINUX_IMMUTABLE)

`u` При удалении файла с установленным атрибутом u его содержимое хранится на жестком диске, что позволяет легко восстановить файл.

`c` Файл будет сжиматься. Рекомендуется для больших несжатых данных, но крайне не желателен для файлов БД т.к. доступ будет медленнее. 

`S` Данные, записываемые в файл, сразу будут сброшены на диск. Аналогично выполнению команды sync сразу после каждой операции записи в файл.

`s` Прямо противоположен атрибуту u. После удаления файла, принадлежащие ему блоки будут обнулены и восстановить их уже не получится.

Пример установки атрибута:
```bash
chattr +i config_file
```
Пример сброса атрибута:
```bash
chattr -i config_file
```

---
# Команда fuser

Чтобы узнать, какой процесс открыл тот или иной ресурс, например, файл или сетевой порт, можно воспользоваться командой `fuser`. Например: 
 
```shell
fuser -va 23/tcp
```

Получим идентификатор процесса, открывшего ТСР порт 23
```shell
fuser -va /chroot/etc/resolv.conf
```

Во втором  случае получим идентификатор процесса, открывшего файл /chroot/ etc/resolv.conf.

Что делать далее - решать вам, например, можно убить этот процесс командой `kill`.

---
# IP адрес

Существует два типа IP-адресов: локальные и публичные.

Локальный IP присваивается системой, и его можно посмотреть с помощью команды:
```shell
hostname -I
```

Если же вы хотите узнать публичный IP вашего ПК, который провайдер присваивает вашему интерфейсу, то при подключённом интернете выполните в командной строке:
```shell
curl ifconfig.co
#или
curl ifconfig.me
```

Команда обращается к серверу `ifconfig.me`, который возвращает обратно IP-шник одной строкой вместо полноценной веб-страницы.

---
# Примеры использования команды wget

Скачивание одного файла:
```shell
wget https://www.example.com/file.zip
```

Скачивание файла с указанием имени:
```shell
wget https://www.example.com/file.zip -O newname.zip
```

Скачивание нескольких файлов из списка:
```shell
wget -i filelist.txt
```
- где filelist.txt содержит список URL-адресов файлов, каждый адрес на новой строке.

Скачивание файла из защищенного соединения:
```shell
wget --user=user --password=password https://www.example.com/file.zip
```

Скачивание файла с использованием прокси-сервера:
```shell
wget --proxy=on --proxy-user=user --proxy-passwd=password https://www.example.com/file.zip
```

Ограничение скорости загрузки:
```shell
wget --limit-rate=100k https://www.example.com/file.zip
```

Продолжение загрузки файла после обрыва связи:
```shell
wget -c https://www.example.com/file.zip
```

Загрузка файла только в случае, если он изменен:
```shell
wget --timestamping https://www.example.com/file.zip
```

Извлечение только определенных типов файлов:
```shell
wget -r -A.png,.jpg https://www.example.com/images/
```

Загрузка файла с использованием определенного User-Agent:
```shell
wget --user-agent="Mozilla/5.0" https://www.example.com/file.zip
```

---
# Бинарные файлы внутри скриптов

Из скрипта можно извлекать предварительно записанные в них бинарные файлы, например архивы. Особенность при создании такого скрипта в том, что сначала надо написать сам скрипт, а потом с помощью команды cat загнать в него необходимый файл. 

После того, как будет написана последовательность команд скрипта, необходимо в конце вставить пустую строку, сохранить скрипт и выполнить в терминале нечто вроде:

```shell
cat my_arch.tar.gz >> my_script.sh
```

После выполнения этой команды архив my_arch.tar.gz станет частью скрипта my_script.sh. Для извлечения архива в приведенном примере используется команда:
```shell
tail -n +30 "$0" > $DEPLOY_PATH/$ARCH_NAME
```
которая в данном случае извлекает бинарные данные и перенаправляет вывод в файл `./libs/jar/odfdom-simple/odfdom-libs.tar.gz. `
Параметр -n +30 означает, что выводить данные надо начиная с 30 строки файла, а под "$0" скрывается имя выполняющегося скрипта.

После того как данные извлечены, можно распаковывать архив, распихивать файлы по каталогам, создавать симлинки и в общем делать всё, что нужно для развертывания вашей системы. Самое главное не забудьте вызвать команду exit до того, как начнутся бинарные данные, иначе bash попытается выполнить и их

(Пример скрипта, который извлекает из себя архив с jar-файлами, распаковывает его и удаляет архив)

```bash
#!/bin/bash

DEPLOY_PATH="./libs/jar/odfdom-simple"
ARCH_NAME="odfdom-libs.tar.gz"

echo "Развертывание библиотек ODFDOM"

# Создание каталога, если его нет
if [ ! -d $DEPLOY_PATH ]; then
    echo "Создание каталога $DEPLOY_PATH"
    mkdir -p $DEPLOY_PATH
fi

echo "Создание скрипта $FIRST_SCRIPT_NAME"

# Вытаскиваем архив из скрипта (начиная с 30-й строки до конца скрипта)
tail -n +30 "$0" > $DEPLOY_PATH/$ARCH_NAME

cd $DEPLOY_PATH

# Распаковка архива
tar xzf $ARCH_NAME

# Удаление архива
rm -f $ARCH_NAME

# Выход из программы с кодом 0
exit 0

############################################################
# здесь начнутся бинарные данные; эту строку 
# включать в скрипт не надо
```

---
# Отображение зависимостей

С помощью команды ldd можно отобразить список динамических библиотек, необходимых для работы вашей программы. Она помогает выявлять отсутствующие зависимости и решать проблемы совместимости.

Основной синтаксис команды ldd выглядит следующим образом:
`ldd [опция]... [файл]...`

Чтобы увидеть список динамических библиотек, необходимых для работы команды /bin/ls, нужно выполнить команду:
```shell
ldd /bin/ls
```

ldd имеет несколько опций, которые могут изменить его поведение:
`--version`: Показать версию ldd.
`--verbose:` Вывести всю информацию, включая информацию о версиях символов.
`--help`: Показать справочное сообщение и выйти.

---
# Отображения дерева зависимостей динамических библиотек

Команда lddtree, являющаяся частью пакета pax-utils, предназначена для отображения зависимостей, необходимых для работы исполняемых файлов или других динамических библиотек. 

lddtree отображает иерархическую структуру зависимостей, что облегчает понимание взаимосвязей между библиотеками.

Чтобы увидеть дерево зависимостей для программы /bin/ls. В этом случае команда будет выглядеть следующим образом:
```shell
lddtree /bin/ls
```

Если у вас ещё не установлен pax-utils, который включает в себя lddtree, вы можете установить его с помощью менеджера пакетов:
Debian или Ubuntu:
```shell
sudo apt-get update
sudo apt-get install pax-utils
```
Fedora:
```shell
sudo dnf install pax-utils
```

---
# Основные сетевые команды Linux

• `ping`: Проверяет подключение к удаленному хосту, отправляя пакеты ICMP.
• `traceroute`: Определяет путь, по которому пакеты проходят от вашего компьютера к удаленному хосту.
• `netstat`: Отображает информацию о сетевых подключениях, маршрутах и статистике.
• `ifconfig`: Отображает и настраивает сетевые интерфейсы.
• `route`: Управляет таблицей маршрутизации.
• `nslookup`: Выполняет поиск в системе доменных имен (DNS).
• `dig`: Более продвинутый инструмент поиска DNS, предоставляющий подробную информацию.
• `arp`: Отображает и управляет таблицей сопоставления IP-адресов и MAC-адресов.
• `tcpdump`: Захватывает и анализирует сетевой трафик.
• `wireshark`: Графический инструмент для захвата и анализа сетевого трафика.
# Управление сетевыми интерфейсами:

• `ifup`: Включает сетевой интерфейс.
• `ifdown`: Выключает сетевой интерфейс.
• `dhclient`: Получает IP-адрес и другую информацию о конфигурации от сервера DHCP.
• `ip`: Управляет сетевыми интерфейсами и адресами с помощью командной строки.
# Настройка сети:

• `hostname`: Устанавливает или отображает имя хоста компьютера.
• `resolv.conf`: Настраивает параметры DNS-сервера.
• `/etc/network/interfaces`: Основной файл конфигурации сети в большинстве дистрибутивов Linux.
# Мониторинг сети:

• `vnstat`: Мониторинг использования полосы пропускания в режиме реального времени.
• `iptraf`: Графический инструмент для мониторинга сетевого трафика.
• `nethogs`: Отображает процессы, использующие сетевое соединение.

---
# Системные  переменные

## Общие системные переменные:
`$SHELL`: Оболочка, используемая текущим процессом.
`$HOME`: Домашний каталог текущего пользователя.
`$PATH`: Список каталогов, в которых оболочка ищет исполняемые файлы.
`$USER`: Имя текущего пользователя.
`$UID`: Идентификатор пользователя (UID) текущего пользователя.
`$PWD`: Текущий рабочий каталог.
`$HOSTNAME`: Имя хоста системы.
`$TERM`: Тип терминала, используемого текущим процессом.
`$LANG`: Языковые настройки системы.
`$LC_ALL`: Настройки локали для всех категорий.
## Переменные окружения, связанные с оболочкой:
`$PS1:` Строка приглашения оболочки.
`$PS2`: Строка продолжения оболочки.
`$IFS`: Внутренний разделитель полей, используемый оболочкой для разделения слов в строке.
`$CDPATH`: Список каталогов, в которых оболочка выполняет команду cd.
`$EDITOR`: Редактор, используемый оболочкой по умолчанию.
`$PAGER`: Программа просмотра, используемая оболочкой по умолчанию.
## Переменные окружения, связанные с командами:
`$0`: Имя текущей команды.
`$1`, `$2`, ...: Аргументы, переданные текущей команде.
`$#`: Количество аргументов, переданных текущей команде.
`$?`: Код выхода последней выполненной команды.
## Переменные окружения, связанные с процессами:
`$PPID`: Идентификатор родительского процесса.
`$PID`: Идентификатор текущего процесса.
`$PPWD`: Текущий рабочий каталог родительского процесса.
## Переменные окружения, связанные с системой:
`$OSTYPE`: Тип операционной системы.
`$ARCH`: Архитектура процессора.
`$KERNELRELEASE`: Версия ядра.
`$VERSION`: Версия дистрибутива Linux.
## Пользовательские переменные окружения:
Пользователи могут создавать свои собственные переменные окружения, используя команду `export`. 
Например: export `MY_VARIABLE=value`

---
# Список открытых файлов и сокетов
Отобразить список открытых файлов и псевдофайлов, в том числе и сокетов, как локальных, так и протоколов TCP и UDP, можно с помощью команды `lsof` 

К примеру, показать все TCP и UDP сокеты 
```shell
lsof -i 
```

Показать все TCP и UDP сокеты, связанные с адресом 192.168.1.5. 
```shell
lsof -i@192.168.1.5 
```

Тоже самое, но при отображении не преобразовывать адреса хостов и номера портов в доменные имена и названия сервисов. 
```shell
lsof -i@192.168.1.5 -n -P 
```

Показать все TCP сокеты; при отображении не преобразовывать адреса хостов и номера портов. 
```shell
lsof -i TCP -n -P 
```

Показать все UDP сокеты, связанные с адресом 192.168.1.5; при отображении не преобразовывать адреса хостов и номера портов. 
```shell
lsof -i UDP@192.168.1.5 -n -P
```

## Чем занимается устройство

Чтобы определить, чем занимается устройство, которое нужно размонтировать, существует полезный инструмент — команда `lsof`. 

>Введите ее с именем нужного раздела, например:
```bash
lsof /mnt/test
```

>Выходные данные покажут, какие команды удерживают файлы открытыми в этом разделе. Таким же образом можно использовать команду: 
```bash
fuser-v /mnt/test
```

---
# Замена традиционной команды ls

`exa` - замена для команды `ls`, написанная на Rust, используется для отображения списка файлов и каталогов. Призвана предоставлять более удобные по умолчанию форматирование и цвета, а также дополнительные функции, такие как дерево каталогов. 

Примеры:
Отобразить список файлов с подробной информацией:
```shell
exa -l
```

Отобразить список файлов, включая скрытые, с подробной информацией:
```shell
exa -la
```

Показать древовидный вывод содержимого каталога:
```shell
exa --tree
```

Показать древовидный вывод содержимого каталога с указанием уровня вложенности:
```shell
exa --tree --level=2
```

Отобразить файлы с информацией о Git-статусе:
```shell
exa -l --git
```

Установка exa зависит от вашего дистрибутива Linux. Например, для дистрибутивов на основе Debian:
```shell
sudo apt install exa
```

---
# Команды системной информации

>отобразить архитектуру компьютера
```shell
arch
```

```shell
uname -m
```

>отобразить используемую версию ядра
```shell
uname -r
```

>показать аппаратные системные компоненты — (SMBIOS / DMI)
```
dmidecode -q
```  

>вывести характеристики жесткого диска
```shell
hdparm -i /dev/hda
```

>протестировать производительность чтения данных с жесткого диска
```shell
hdparm -tT /dev/sda
```

>отобразить информацию о процессоре
```shell
cat /proc/cpuinfo
```

>показать прерывания
```shell
cat /proc/interrupts
```

>проверить использование памяти
```shell
cat /proc/meminfo
```

>показать файл(ы) подкачки
```shell
cat /proc/swaps
```

>вывести версию ядра
```shell
cat /proc/version
```

>показать сетевые интерфейсы и статистику по ним
```shell
cat /proc/net/dev
```

>отобразить смонтированные файловые системы
```shell
cat /proc/mounts
```

>показать в виде дерева PCI устройства
```shell
lspci -tv
```

>показать в виде дерева USB устройства
```shell
lsusb -tv
```

>вывести системную дату
```shell
date
```

>вывести таблицу-календарь 2024-го года
```shell
cal 2024
```

>установить системные дату и время ММДДЧЧммГГГГ.СС (МесяцДеньЧасМинутыГод.Секунды)
```shell
date 052012002024.00
```

>сохранить системное время в BIOS
```shell
clock -w
```

---
# Команда xargs

Возможность объединения нескольких команд Linux в терминале и использования их в качестве конвейера, когда каждая следующая команда получает вывод предыдущей - очень мощный и гибкий инструмент. Но команды можно объединять не только так. С помощью утилиты xargs вывод предыдущей команды можно передать в аргументы следующей.

Синтаксис команды:
команда1 | xargs опции команда2 аргументы

Сначала выполняется любая первая команда и весь её вывод по туннелю передается в xargs. Затем этот вывод разбивается на строки и для каждой строки вызывается вторая команда, а полученная строка передаётся ей в аргументах.

С помощью этой команды можно например вывести все имена файлов из папки ~/folder:
```bash
ls ~/folder | xargs -t -L1 echo
```

`-t` — используется, чтобы подробнее понять, что происходит
`-L1` — указывает сколько строк надо передавать в одну команду

---
# Модули ядра Linux

Ядро Linux — является монолитным ядром. 
Это значит, что весь исполняемый код сосредоточен в одном файле. Такая архитектура имеет некоторые недостатки, например, невозможность установки новых драйверов без пересборки ядра. Но разработчики нашли решение и этой проблеме, добавив систему модулей.

Модули ядра Linux собираются только под определенную версию ядра и находятся в папке /lib/modules/.

Основные команды для управления модулями.
 ⁃ `lsmod` - посмотреть загруженные модули
 ⁃ `modinfo` - информация о модуле
 ⁃ `insmod` - загрузить модуль
 ⁃ `rmmod` - удалить модуль

Чтобы посмотреть все установленные модули ядра Linux (DEB) в системе:
```bash
dpkg -S *.ko | grep /lib/modules
```

---
# История команд
Если открыть окно терминала и ввести несколько команд, а после открыть второе окно, то история команд bash во втором окне не будет содержать команд из первого. К тому же, если закрыть первый терминал, а затем второй, то история команд из первого терминала будет перезаписана вторым. 

Так происходит из-за того, что история команд записывается только при закрытии терминала, а не после каждой команды. Это можно исправить.

Отредактируем файл `.bashrc` 

добавив в него строки:

```
shopt -s histappend

PROMPT_COMMAND='history -a'
```

Так история команд будет добавляться к старой, а не перезаписывать ее, и запись будет происходить каждый раз в момент отображения подсказки bash.

---
# Справка по важным спецсимволам bash

- `;` Отделение команд друг от друга
- `:` Команда оболочки, ничего не делает
- `.` Запуск оболочки без собственного командного подпроцессора (.file соответствует исходному файлу)
- `#` Ввод комментария
- `#!/bin/sh` Идентификация оболочки, в которой будет выполняться программа
- `&` Выполнение команды в фоновом режиме (com &)
- `&&` Выполнение одной команды в зависимости от результата другой (com1 && com2)
- `&>` Переадресация стандартного вывода и ошибок (соответствует >&)
- `|` Создание программных каналов (com1 | com2)
- `||` Выполнение одной команды в зависимости от результата другой (com1 || com2)
- `*` Джокерный символ для имен файлов (любое количество символов)
- `?` Джокерный символ для имен файлов (любой символ)
- `[abc]` Джокерный символ для имен файлов (любой символ из abc)
- `[ expression ]` Сокращенный вариант записи test expression
- `(...)` Выполнение команд в той же оболочке ((сom1; сom2))
- `{...}` Группирование команд
- `{ , , }` Объединение нескольких последовательностей символов (a{1,2,3} → a1 a2 a3)
- `{a..b}` Объединение нескольких последовательностей символов (b{4..6} → b4 b5 b6)
- `~` Сокращенное обозначение домашнего каталога
- `>` Переадресация вывода в файл (com > file)
- `>>` Переадресация вывода и добавление его в существующий файл
- `>&` Переадресация стандартного вывода и ошибок (соответствует &>)
- `2>` Переадресация стандартного вывода ошибок
- `<` Переадресация ввода из файла (com < file)
- `<< end` Переадресация ввода из активного файла до завершения
- `$` Обозначение переменных (echo $var)
- `$!` Номер PID последнего процесса, запущенного в фоновом режиме
- `$$ PID` актуальной оболочки
- `$0` Имя выполняемого в данный момент сценарного файла оболочки
- `$1–$9` Первые девять параметров, переданных команде
- `$#` Количество параметров, переданных программе оболочки
- `$*` или `$@` Совокупность всех переданных параметров
- `$?` Возвращаемое значение последней команды (0=OK или номер ошибки)
- `$(...)` Подстановка команд (echo $(ls))
- `${...}` Различные специальные функции для обработки последовательностей символов
- `$[...]` Арифметические вычисления (echo $[2+3])
- `"..."` Предотвращение интерпретации большинства специальных символов
- `'...'` Предотвращение интерпретации всех специальных символов
- <code>&#96;</code>`...`<code>&#96;</code> Подстановка команд (echo \`ls\`)

---
# Журнал ядра

Для просмотра сообщений ядра используем команду
```bash
journalctl -k 
```

Команда покажет все сообщения ядра для текущей загрузки. 

Такую команду можно комбинировать с опцией `-b`, чтобы просмотреть сообщения ядра во время предыдущей загрузки:
```bash
journalctl -k -b -2
```

Но бывает такое, что в некоторых системах boot logging отключен и вместо лога предыдущих загрузок получаем сообщение: `"Specifying boot ID has no effect, no persistent journal was found"`

Исправляем ситуацию так: 
В файле /etc/systemd/journald.conf  параметр  Storage выставляем в persistent - Storage=persistent
И перезапускаем сервис командой:
```bash
systemctl restart systemd-journald
```

Должно сработать:
`journalctl -k -b -0` - текущая загрузка
`journalctl -k -b -1` - предыдущая
`journalctl -k -b -2` - предыдущая предыдущая
`journalctl -k -b -n` - и т. д.

---
# Узнаем количество строк в файле

Команда wc, которая считает количество переходов на новую строку, ранее упоминалась (https://t.me/os_linux_ru/228). 
Рассмотрим еще три способа, как посчитать количество строк в файле с помощью команд:

1. GREP
```bash
grep -c $ file_name
```

2. SED
```bash
sed -n \$= file_name
```

3. AWK
```bash
awk 'END{ print NR }' file_name
```

# Считаем контрольные суммы файлов

Подсчитать контрольные суммы файлов можно с помощью нескольких команд: cksum, md5sum, sha1sum и sha256sum.

Контрольная сумма - последовательность цифр и букв, используемых для проверки целостности данных на наличие ошибок.

Синтаксис команд прост, как никогда:

```bash
cksum <filename>
```

```bash
md5sum <filename>
```

```bash
sha1sum <filename>
```

```bash
sha256sum <filename>
```

---
# Инструмент сетевой диагностики MTR

`mtr` объединяет функциональность `traceroute` и `ping` в один инструмент.

После запуска mtr проверяет сетевое соединение между локальной системой и указанным удаленным хостом. Сначала mtr устанавливает адрес каждого сетевого перехода между хостами, затем он пингует каждому из них, чтобы определить качество отклика на каждой машине.

Простейшим примером использования mtr является предоставление имени домена или IP-адреса удаленной машины в качестве аргумента, к примеру:
```bash
mtr google.com
```

---
# diff и cmp — сравнение файлов

Команда `diff` служит для сравнения двух файлов. Формат вызова команды:
`diff [параметры] файл1 файл2`
В выводе команды отличающиеся строки помечаются символами:
- строка из первого файла помечается символом `<`;
- строка из второго файла — символом `>`.

полезные параметры команды diff:
`-b` Игнорируются пробельные символы в конце строки
`-В` Игнорируются пустые строки
`-е` Используется при создании сценария для редактора ed. Этот сценарий превращает первый файл во второй
`-w` Игнорируются пробельные символы
`-у` Вывод в два столбца
`-r` Используется для сравнения файлов в подкаталогах. Вместо первого файла указывается первый каталог, вместо второго файла — соответственно, второй каталог.

Команда `cmp` также служит для сравнения двух файлов: если файлы идентичны, то ничего не выводит, а вот если файлы отличаются, то cmp выводит номер строки и номер символа в строке, откуда начинается различие.

Команда cmp более универсальна, поскольку она может использоваться для сравнения как текстовых, так и двоичных файлов. В отличие от нее, команда diff и ее аналоги умеют сравнивать только текстовые файлы.
Формат вызова команды сmp следующий:
`cmp [параметры] файл1 файл2`

полезные параметры команды cmp:
`-с` Вывод отличающихся символов
`-i `n Игнорировать первые n символов
`-l `Вывод позиций всех отличий, а не только первого
`-s` Не выводить информацию на экран, при этом код возврата будет следующим:
    0 — файлы одинаковые;
    1 — файлы отличаются;
    2 — ошибка при открытии одного из файлов

---
# Сохраняем сайт целиком

```bash
wget -m -p -k -E https://xtls.github.io/ru/config/
```

---
# Арифметические операции

Если необходимо использовать арифметические операторы в сценариях оболочки, поможет команда expr (которая выполняет даже некоторые операции со строками). 

>Например: 
```
expr 5 + 2
```
выводит результат 7. 

>Полный перечень операций:
```bash
expr --help
```

>`expr` не хранит результат, а по умолчанию просто печатает ответ. Но никто не запрещает сохранять результат в переменные: 
```bash
A=$( expr 12 - 7 )
echo $A # 5
```

---
# Копирование файлов по ssh

>Чтобы скопировать локальный файл myfile.txt на компьютер с IP адресом 192.168.12.124 в директорию /home/mycomputer:
```bash
scp myfile.txt mycomputer@192.168.12.124:/home/mycomputer
```

>А наоборот, скопировать файл с удаленного компьютера в текущую директорию:
```bash
scp mycomputer@192.168.12.124:/home/mycomputer
```

Также копировать можно не только файлы, но и и целые директории. 

>Чтобы скопировать с локального компьютера директорию ~/mydir на удаленный компьютер в директорию /home/mycomputer:
```bash
scp -r ~/mydir mycomputer@192.168.1.17:/home/mycomputer
```

---
# Управление буфером обмена из командной строки
Буфер обмена — непостоянное хранилище на вашем компьютере данных, которые пользователь хочет скопировать с одного пути на другой.

`Xclip` — отличный инструмент, который используется в качестве буфера обмена. 

>Устанавливаем Xclip в Debian/Ubuntu:
```bash
 sudo apt install xclip
```

Примеры использования:

>Предположим, вы хотите скопировать имя любого веб-сайта в буфер обмена, а затем, позже, вы также можете вставить его с помощью:
```bash
echo "<URL>" | xclip
```

>Отобразить дату и время с помощью буфера обмена:
```bash
date | xclip
```

>Копирование содержимого любого текстового файла и затем вставка его в терминал:
```bash
 cat textfile.txt | xclip
```

---
# Генерация пароля

>Будет сгенерирован пароль 32 символа
```bash
openssl rand -base64 32 | tr -dc 'A-Za-z0-9%$#*'
```

---
# Кастомная сборка драйверов в Linux

Иногда стандартные драйверы не подходят, и требуется собрать их вручную. Это может быть необходимо, если устройство не поддерживается текущим ядром или нужно использовать более свежую версию драйвера.
Шаги для сборки драйвера:

1. Качаем исходный код с официального сайта или GitHub.
```bash
git clone https://github.com/xyz/driver.git
```

2. Устанавливаем необходимые пакеты.
```bash
sudo apt-get install build-essential linux-headers-$(uname -r)
```

3. Собираем:
```bash
cd driver
make
```

4. Устанавливаем:
```bash
sudo make install
```

5. Загружаем модуль ядра:
```bash
sudo modprobe <module_name>
```

Когда не стоит собирать драйверы вручную:
- Если драйвер несовместим с вашим ядром.
- Если требуется модификация ядра, что сложно для новичков.

---
# Распространенные проблемы с драйверами и их решения

1.  Драйвер не работает после обновления ядра
Возможно, требуется пересборка драйвера. Используйте DKMS, чтобы драйверы автоматически компилировались при обновлении ядра.

2. Графические артефакты или низкий FPS
Проверьте, работает ли аппаратное ускорение:
```bash
glxinfo | grep "direct rendering"
```
Если вывод: Yes, ускорение работает.

3. Устройство не определяется
Проверьте, распознается ли устройство системой:
```bash
lspci | grep -i <устройство>
```
Если нет, возможно, требуется установка драйвера вручную.

4. Конфликт драйверов
Если несколько драйверов загружены одновременно, отключите ненужный драйвер:
```bash
sudo modprobe -r <драйвер>
```

---
# Проверка поддержки устройства в ядре Linux

Когда подключаем новое устройство к Linux, важно убедиться, что оно будет корректно работать с системой. Одним из шагов в этом процессе является проверка, поддерживает ли устройство ядро Linux. 

Для того чтобы узнать, поддерживает ли устройство ядро, используем команду lspci -nnk, которая покажет информацию о подключенных устройствах и драйверах:
```bash
lspci -nnk | grep -A3 -i <тип устройства>
```

Пример вывода:
```
01:00.0 VGA compatible controller [0300]: NVIDIA Corporation GP104 [GeForce GTX 1070] [10de:1b81] (rev a1)
    Subsystem: NVIDIA Corporation Device [10de:11f0]
    Kernel driver in use: nvidia
    Kernel modules: nvidia, nvidiafb
```

Здесь:
`Kernel driver in use `— показывает, какой драйвер используется для устройства (в данном примере это nvidia).
`Kernel modules `— указывает, какие модули ядра могут быть загружены для работы с устройством (например, nvidia и nvidiafb).

Если для устройства указано имя драйвера, значит оно поддерживается ядром Linux. Если же драйвера нет, возможно, придется искать решение через Open Source драйвера или использовать драйверы Windows с помощью Wine/ndiswrapper.

---
# Проверка графических драйверов

1. С помощью команды lshw: показывает подробную информацию об оборудовании, включая используемые драйверы.
```bash
sudo lshw -c video
```

Вывод будет содержать строку, указывающую на используемый драйвер, например:
```
configuration: driver=nouveau latency=0
```

2. С помощью glxinfo. Если используется OpenGL, команда glxinfo показывает активный драйвер.
```bash
glxinfo | grep "OpenGL renderer"
```

Пример вывода:
```
OpenGL renderer string: Mesa Intel(R) UHD Graphics 620
```

3. С помощью vulkaninfo. Для Vulkan вы можете проверить активные драйверы:
```bash
vulkaninfo | grep "driverName"
```